#!/bin/sh
#
# Teng -- a general purpose templating engine.
# Copyright (C) 2004  Seznam.cz, a.s.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Seznam.cz, a.s.
# Naskove 1, Praha 5, 15000, Czech Republic
# http://www.seznam.cz, mailto:teng@firma.seznam.cz
#
#
# $Id: make.sh,v 1.2 2005-04-11 19:08:26 solamyl Exp $
#
# DESCRIPTION
# Packager for Teng library.
#
# AUTHORS
# Vaclav Blazek <blazek@firma.seznam.cz>
#
# HISTORY
# 2004-05-03  (vasek)
#             Created.
#

########################################################################
# Command line options.                                                #
########################################################################
while [ "$#" != "0" ]; do
    case "$1" in
        --help)
            echo "Usage: make.sh [--with-python=PYTHON] [--debug] [--help]"
            echo "    --with-python PYTHON"
            echo "    --with-python=PYTHON sets python interpreter for which to build"
            echo "                         a package (defaults to 'python')"
            echo "    --default            create empty package for default python"
            echo "    --debug              log every command to stderr (set -x)"
            echo "    --help               show this help"
            echo ""
            echo "    When --default is specified, program creates python-teng package"
            echo "    which depends on python with current version in debian. When "
            echo "    not specified, program creates python<minor>.<major>-teng package"
            echo "    which depends on python<minor>.<major>"
            echo ""
            echo "    To change package's version please edit file python-teng.version"
            echo "    in this directory. Control file is generated by expanding @tags@"
            echo "    in the python-teng.control file."
            echo ""
            echo "    You can also create python-teng.postinst, python-teng.preinst,"
            echo "    python-teng.conffiles, python-teng.prerm and python-teng.postrm"
            echo "    files that would be used as postinst, preinst, conffiles, prerm"
            echo "    and postrm files in the package."
            exit 0
        ;;

        --debug)
            set -x
            DEBUG="debug"
        ;;

        --default)
            PYTHON=python
            DEFAULT=yes
        ;;
        
        --with-python=*)
            PYTHON=${1:14}
        ;;

        --with-python)
            PYTHON=$2
            shift
        ;;

        # hidden parameter for recursive calling of make.sh
        --make-binary)
            MODE="binary"
        ;;
            
        *)
            echo "Unknown option '$1', try make.sh --help." >> /dev/stderr
            exit 1
        ;;
    esac
    shift
done


function make_dirs {
    # Create package destination directory.
    PACKAGE_DIR=pkg
    mkdir -p ${PACKAGE_DIR}

    # Create build directory (force it to be clean).
    BUILD_DIR=build
    mkdir -p ${BUILD_DIR}
    rm -Rf ${BUILD_DIR}

    # Create directories and set their attributes.
    DEBIAN_BASE=${BUILD_DIR}/${PACKAGE_NAME}
    CONTROL_DIR=${DEBIAN_BASE}/DEBIAN
    mkdir -p ${CONTROL_DIR}
    chmod 0755 ${CONTROL_DIR}
}

function build_package {
    ########################################################################
    # Package housekeeping                                                 #
    ########################################################################

    if [ "${DEFAULT}" = "no" ]; then
        # Copy extra package files.
        for FILE in postinst preinst prerm postrm; do
            if test -f ${PROJECT_NAME}.${FILE}; then
                cp ${PROJECT_NAME}.${FILE} ${CONTROL_DIR}/${FILE}
                chmod 755 ${CONTROL_DIR}/${FILE}
            fi
        done
    
        # Copy unrunnable files
        test -f ${PROJECT_NAME}.conffiles \
                && cp ${PROJECT_NAME}.conffiles ${CONTROL_DIR}/conffiles
    fi
    
    # Remove any lost CVS entries in the package tree.
    find ${DEBIAN_BASE} -path "*CVS*" -exec rm -Rf '{}' \; || exit 1

    # Dependencies to the system libraries (libc, libstdc++, ...)
    STANDARD_DEPEND=""
    ldd_libs=$(ldd $(find ${INSTALL_DIR}/usr/lib -name '*.so') \
            | grep -e libc -e libstdc -e libteng \
            | cut -f2 -d'>' | cut -f1 -d'(' | sort | uniq)
    for lib in ${ldd_libs}; do
        # determine .deb package from library file
        pkg=$(dpkg -S ${lib} | cut -f1 -d':')
        if [ "${STANDARD_DEPEND}" = "" ]; then
            STANDARD_DEPEND=${pkg}
        else
            STANDARD_DEPEND=${STANDARD_DEPEND}", "${pkg}
        fi
    done
    
    # Compute package's size.
    SIZEDU=$(du -sk ${DEBIAN_BASE} | awk '{print $1}') || exit 1
    SIZEDIR=$(find ${DEBIAN_BASE} -type d | wc | awk '{print $1}') || exit 1
    SIZE=$[ $SIZEDU - $SIZEDIR ] || exit 1
    
    VERSION=$(< ${PROJECT_NAME}'.version')
    
    # Process control file -- all <tags> will be replaced with
    # appropriate data.
    sed     -e "s/@VERSION@/${VERSION}/" \
            -e "s/@PACKAGE@/${PACKAGE_NAME}/" \
            -e "s/@MAINTAINER@/${MAINTAINER}/" \
            -e "s/@ARCHITECTURE@/$(dpkg --print-architecture)/" \
            -e "s/@SIZE@/${SIZE}/" \
            -e "s/@STANDARD_DEPEND@/${STANDARD_DEPEND}/" \
            -e "s/@EXTRA_DEPEND@/${EXTRA_DEPEND}/" \
            ${PROJECT_NAME}.control > ${CONTROL_DIR}/control || exit 1

    # Create and rename the package.
    dpkg --build ${DEBIAN_BASE} ${PACKAGE_DIR}/${PACKAGE_NAME}.deb || exit 1
    dpkg-name -o ${PACKAGE_DIR}/${PACKAGE_NAME}.deb || exit 1

    # Get rid of temporary build directory.
    rm -r ${BUILD_DIR}
}

# determine operation
if [ "${MODE}" = "binary" ]; then
    # we are making binarty package -- called recursively from make.sh
    # Make all directories
    make_dirs || exit 1

    ########################################################################
    # Copy all files                                                       #
    ########################################################################

    if [ "${DEFAULT}" = "no" ]; then
        # copy all to the package
        cp -vR ${INSTALL_DIR}/* ${DEBIAN_BASE}/ || exit 1
    fi

    # Build the package
    build_package
    exit $?
fi


########################################################################
# Retrieve information from the Python packages setup.py.              #
########################################################################

# project name
PROJECT_NAME="python-teng"

# Maintainer of this module
MAINTAINER="Vaclav Blazek <blazek@firma.seznam.cz>"

# Set defaults if not set
if [ "${PYTHON}" = "" ]; then
    PYTHON="python"
fi
if [ "${DEFAULT}" = "" ]; then
    DEFAULT="no"
fi

# Run Python interpreter to obtain its version and construct
# package name from it.
PYTHON_VERSION=$(${PYTHON} <<EOF
import sys
print sys.version[:3]
EOF) || exit 1

# get version of next python (<major>.<minor + 1>)
if [ "${DEFAULT}" = "yes" ]; then
    NEXT_PYTHON_VERSION=$(${PYTHON} <<EOF
import sys
major = int(sys.version[0])
minor = int(sys.version[2])
print "%d.%d" % (major, minor + 1)
EOF) || exit 1

    # Compose package name 'python-teng'
    dash=$(echo ${PROJECT_NAME} | grep -e'-')
    if [ "${dash}" = "" ]; then
        PACKAGE_NAME="python-${PROJECT_NAME}"
        PYTENG_PACKAGE="python${PYTHON_VERSION}-${PROJECT_NAME}"
    else
        PACKAGE_NAME=${PROJECT_NAME}
        name=$(echo ${PROJECT_NAME} | cut -f1 -d'-')
        suff=$(echo ${PROJECT_NAME} | cut -f2- -d'-')
        PYTENG_PACKAGE=${name}${PYTHON_VERSION}-${suff}
    fi
    # Dependece to the name of the python interpreter
    EXTRA_DEPEND="python (>= ${PYTHON_VERSION}), python (<< ${NEXT_PYTHON_VERSION})"
    # Add dependence to real 'python?.?-teng' package
    EXTRA_DEPEND="${EXTRA_DEPEND}, ${PYTENG_PACKAGE}"

    # Inform about package name.
    echo "Building empty package (${PACKAGE_NAME}) for default python. Python interpreter reset to python."
else
    # Compose package name 'python2.3-teng'
    dash=$(echo ${PROJECT_NAME} | grep -e'-')
    if [ "${dash}" = "" ]; then
        PACKAGE_NAME="python${PYTHON_VERSION}-${PROJECT_NAME}"
    else
        name=$(echo ${PROJECT_NAME} | cut -f1 -d'-')
        suff=$(echo ${PROJECT_NAME} | cut -f2- -d'-')
        PACKAGE_NAME=${name}${PYTHON_VERSION}-${suff}
    fi
    # Dependence to the name of the python interpreter
    EXTRA_DEPEND="python${PYTHON_VERSION}"

    # Inform about package name.
    echo "Building package ${PACKAGE_NAME}."
fi

########################################################################
# Build and install.                                                   #
########################################################################

# Create install directory.
INSTALL_DIR=$(pwd)/"install"
rm -Rf ${INSTALL_DIR}
mkdir -p ${INSTALL_DIR}

# Build and install module in the subshell.
if [ "${DEFAULT}" = "no" ]; then
    (
        # go to the setup.py's directory (is must be run from its
        # own directory) 
        cd ..;
        # clean all residuals from previous run
        ${PYTHON} setup.py clean --quiet --all
        # build and install everything
        ${PYTHON} setup.py install --quiet --root=${INSTALL_DIR}
    ) || exit 1
fi

########################################################################
# Call packagers to create both binary an dev packages.                #
########################################################################

# Variable INSTALL_DIR must be exported for propper
# operation of packages.

export PROJECT_NAME
export MAINTAINER
export INSTALL_DIR
export PACKAGE_NAME
export EXTRA_DEPEND
export DEFAULT
export DEBUG

# Create binary package (must be run under fakeroot).
fakeroot ./make.sh --make-binary || exit 1

# Get rid of residuals
rm -Rf ${INSTALL_DIR}
